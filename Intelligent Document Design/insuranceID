import os
import boto3
import json
import time
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Initialize AWS clients
aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
aws_secret_access_key = os.getenv("AWS_SECRET_ACCESS_KEY")
aws_region = os.getenv("AWS_REGION")
index_1 = 34
entity_tag1 = "b07034666f0fbee7461b1202a52e2cc5"

s3 = boto3.client('s3', aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key)
textract = boto3.client('textract', aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, region_name=aws_region)

def get_s3_bucket_object_by_index(bucket, index=index_1):
    if index is None:  # Check if the index is None
        return None  # Skip the array index search and directly go to the entity tag

    paginator = s3.get_paginator('list_objects_v2')  # Paginate through the bucket
    operation_parameters = {'Bucket': bucket}
    page_iterator = paginator.paginate(**operation_parameters)

    # Loop through all pages and objects
    all_object_keys = []  # Store all object keys here for debugging purposes
    for page in page_iterator:
        if 'Contents' in page and page['Contents']:
            object_keys = [item['Key'] for item in page['Contents']]
            all_object_keys.extend(object_keys)  # Collect all object keys

    # Check if the index is valid
    if len(all_object_keys) > index:
        return all_object_keys[index]  # Return the object key at the given index
    else:
        print(f"Index {index} is out of range. Total objects available: {len(all_object_keys)}")
    return None  # Return None if index is out of bounds

def get_s3_bucket_object_by_tag(bucket, entity_tag):
    paginator = s3.get_paginator('list_objects_v2')  # Paginate through the bucket
    operation_parameters = {'Bucket': bucket}
    page_iterator = paginator.paginate(**operation_parameters)

    # Loop through all pages and objects
    for page in page_iterator:
        if 'Contents' in page and page['Contents']:
            for item in page['Contents']:
                object_key = item['Key']
                try:
                    # Fetch the object's metadata
                    metadata = s3.head_object(Bucket=bucket, Key=object_key)
                    # Check if the ETag matches the desired entity tag
                    if 'ETag' in metadata and metadata['ETag'].strip('"') == entity_tag:
                        return object_key  # Return the object key if the ETag matches
                except Exception as e:
                    print(f"Error fetching metadata for {object_key}: {e}")
    return None  # Return None if no matching entity tag is found

def textract_extract_text(bucket, object_key):
    try:
        row = []
        # Ensure the correct S3 URL format is passed to Textract
        s3_url = f"s3://{bucket}/{object_key}"

        # Check file extension (PNG, JPEG, or PDF)
        file_extension = object_key.split('.')[-1].lower()

        if file_extension in ['png', 'jpg', 'jpeg']:  # Handle image files
            # Call AWS Textract directly using boto3 for image files
            response = textract.analyze_document(
                Document={'S3Object': {'Bucket': bucket, 'Name': object_key}},
                FeatureTypes=["FORMS"]
            )
        elif file_extension == 'pdf':  # Handle PDF files
            # Start document analysis for PDFs (asynchronously)
            response = textract.start_document_analysis(
                DocumentLocation={'S3Object': {'Bucket': bucket, 'Name': object_key}},
                FeatureTypes=["FORMS"]
            )
            # Wait for the analysis to complete
            job_id = response['JobId']
            print(f"Started asynchronous job for PDF with JobId: {job_id}")

            # Wait for the job to finish (or implement a retry mechanism)
            while True:
                result = textract.get_document_analysis(JobId=job_id)
                status = result['JobStatus']
                if status in ['SUCCEEDED', 'FAILED']:
                    break
                print("Waiting for Textract to complete the analysis...")
                time.sleep(5)  # Wait for 5 seconds before checking again

            if status == 'SUCCEEDED':
                response = result  # Use the analysis result
            else:
                raise ValueError("Textract document analysis failed.")

        else:
            raise ValueError(f"Unsupported file format: {file_extension}")

        if isinstance(response, str):
            response = json.loads(response)  # Convert string to JSON dictionary if necessary

        if response is None:
            raise ValueError("Textract response is None")

        row.append(response)  # Store the response for later use
        return row

    except Exception as e:
        print(f"Error in textract_extract_text: {e}")
        return None

def structure_text(response):
    # Extract the text from the Textract response dictionary
    text = ""
    blocks = response.get('Blocks', [])
    
    # Iterate over the blocks to extract text (typically from 'WORD' or 'LINE' blocks)
    for block in blocks:
        if block['BlockType'] == 'WORD' or block['BlockType'] == 'LINE':
            text += block.get('Text', '') + '\n'
    
    # Split the text into sections based on the '\n' character
    sections = {}
    current_section = None

    for line in text.split('\n'):
        if line.strip() == "":
            current_section = None
        elif line.isupper():
            current_section = line
            sections[current_section] = []
        elif current_section:
            sections[current_section].append(line)
        else:
            current_section = "PARAGRAPH"
            if current_section not in sections:
                sections[current_section] = []
            sections[current_section].append(line)

    for section, content in sections.items():
        sections[section] = ' '.join(content).strip()

    return sections, text  # Return both sections and the full text for label extraction

def extract_information(response):
    patient_info = {}
    doctor_info = {}

    key_map = {}
    value_map = {}
    block_map = {}

    blocks = response.get('Blocks', [])
    if not blocks:
        raise ValueError("No blocks found in Textract response")

    for block in blocks:
        block_id = block['Id']
        block_map[block_id] = block
        if block['BlockType'] == "KEY_VALUE_SET":
            if 'KEY' in block['EntityTypes']:
                key_map[block_id] = block
            else:
                value_map[block_id] = block

    def get_kv_relationship(key_map, value_map, block_map):
        kvs = {}
        for block_id, key_block in key_map.items():
            value_block = None
            for relationship in key_block.get('Relationships', []):
                if relationship['Type'] == 'VALUE':
                    for value_id in relationship['Ids']:
                        value_block = value_map.get(value_id)
                        break
            key = get_text(key_block, block_map)
            value = get_text(value_block, block_map)
            kvs[key] = value
        return kvs

    def get_text(result, blocks_map):
        text = ''
        if result and 'Relationships' in result:
            for relationship in result['Relationships']:
                if relationship['Type'] == 'CHILD':
                    for child_id in relationship['Ids']:
                        word = blocks_map[child_id]
                        if word['BlockType'] == 'WORD':
                            text += word['Text'] + ' '
                        if word['BlockType'] == 'SELECTION_ELEMENT':
                            if word['SelectionStatus'] == 'SELECTED':
                                text += 'X '
        return text.strip()

    kvs = get_kv_relationship(key_map, value_map, block_map)

    for key, value in kvs.items():
        # Refine handling for Member Name and Member ID
        if "Member Name" in key:
            # Extract only the name part (before the ID number)
            name_value = value.strip()
            # Split by spaces, and make sure to exclude the Member ID (last part)
            name_parts = name_value.split(" ")
            if len(name_parts) > 1:
                patient_info["Member Name"] = " ".join(name_parts[:-1])  # Take all parts except the last one
                patient_info["Member ID"] = name_parts[-1]  # The last part is the Member ID
            else:
                patient_info["Member Name"] = name_value
                patient_info["Member ID"] = ""  # If no ID is found in the same string
        elif "Mother" in key or "Infant" in key or "Patient" in key:
            patient_info[key] = value
        elif "Physician" in key or "Doctor" in key or "PCP" in key:
            doctor_info[key] = value

    return {
        "patient": patient_info,
        "doctor": doctor_info
    }

def main(bucket_name, entity_tag_to_find, index=None):
    object_key = None

    # Try to retrieve the document by array index if index is not None
    if index is not None:
        object_key = get_s3_bucket_object_by_index(bucket_name, index)
    
    # If no object key is found by index or index is None, fallback to entity tag
    if not object_key:
        print(f"Object not found by index or index is None, searching by entity tag '{entity_tag_to_find}'")
        object_key = get_s3_bucket_object_by_tag(bucket_name, entity_tag_to_find)

    if object_key:
        print(f"Found document - Object Key: {object_key}")
        text_data = textract_extract_text(bucket_name, object_key)
        if text_data:
            # Extract and structure the text
            structured_text, full_text = structure_text(text_data[0])  # Pass the response directly
            
            # Extract the first line of text (from the full_text variable) for the label
            first_line = full_text.split('\n')[0].strip() if full_text else "No Label Found"
            
            # Extract specific information and format as JSON
            extracted_info = extract_information(text_data[0])
            
            # Add the label to the extracted information
            extracted_info_with_label = {
                "document label": first_line,
                "extracted information": extracted_info
            }

            # Print the extracted information with the label
            print(json.dumps(extracted_info_with_label, indent=2))
        else:
            print("Failed to extract text from the document.")
    else:
        print("No object found with the given index or entity tag.")

if __name__ == "__main__":
    bucket_name = "capstone-intelligent-document-processing"  # Replace with your actual S3 bucket name
    entity_tag_to_find = entity_tag1  # Replace with the desired entity tag
    main(bucket_name, entity_tag_to_find, index=index_1)
