import os
import boto3
import json
import time
import re
from dotenv import load_dotenv
import trp.trp2 as t2
from tabulate import tabulate

# Load environment variables
load_dotenv()

# Initialize AWS clients
aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
aws_secret_access_key = os.getenv("AWS_SECRET_ACCESS_KEY")
aws_region = os.getenv("AWS_REGION")

s3 = boto3.client('s3', aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key)
textract = boto3.client('textract', aws_access_key_id=aws_access_key_id, aws_secret_access_key=aws_secret_access_key, region_name=aws_region)

# Define the entity tag to search for
entity_tag = "24eb56b8e0742c7b8637746517198223"  # Replace with the actual entity tag

def get_s3_bucket_object_by_tag(bucket, tag):
    paginator = s3.get_paginator('list_objects_v2')
    operation_parameters = {'Bucket': bucket}
    page_iterator = paginator.paginate(**operation_parameters)

    for page in page_iterator:
        if 'Contents' in page and page['Contents']:
            for item in page['Contents']:
                head_object = s3.head_object(Bucket=bucket, Key=item['Key'])
                if 'ETag' in head_object and head_object['ETag'].strip('"') == tag:
                    return item['Key']
    
    print(f"No object found with tag: {tag}")
    return None

def textract_analyze_with_queries(bucket, object_key):
    try:
        # Start asynchronous document analysis with queries
        response = textract.start_document_analysis(
            DocumentLocation={'S3Object': {'Bucket': bucket, 'Name': object_key}},
            FeatureTypes=["QUERIES", "SIGNATURES", "FORMS"],
            QueriesConfig={"Queries": [
                {"Text": "What is the customer name?", "Alias": "SIGNER_NAME"},
                {"Text": "What is the date signed?", "Alias": "SIGNING_DATE"}
            ]}
        )
        
        job_id = response['JobId']
        print(f"Started asynchronous job for PDF with JobId: {job_id}")

        # Poll for job completion
        while True:
            result = textract.get_document_analysis(JobId=job_id)
            status = result['JobStatus']
            if status in ['SUCCEEDED', 'FAILED']:
                break
            print("Waiting for Textract to complete the analysis...")
            time.sleep(5)

        if status == 'SUCCEEDED':
            # Get all pages from the job
            pages = []
            next_token = None
            
            while True:
                if next_token:
                    result = textract.get_document_analysis(JobId=job_id, NextToken=next_token)
                else:
                    result = textract.get_document_analysis(JobId=job_id)
                
                pages.append(result)
                
                if 'NextToken' in result:
                    next_token = result['NextToken']
                else:
                    break
            
            # Combine all pages into a single response
            combined_response = pages[0]  # Start with the first page
            if len(pages) > 1:
                for page in pages[1:]:
                    combined_response['Blocks'].extend(page['Blocks'])
            
            # Extract raw text for pattern matching
            raw_text = ""
            for block in combined_response.get('Blocks', []):
                if block.get('BlockType') in ['LINE'] and 'Text' in block:
                    raw_text += block.get('Text', '') + "\n"
            
            print("Raw text extracted for pattern matching")
            
            return combined_response, raw_text
        else:
            raise ValueError("Textract document analysis failed.")

    except Exception as e:
        print(f"Error in textract_analyze_with_queries: {e}")
        return None, None

def detect_signature(response):
    """Check if a signature is present in the document"""
    try:
        blocks = response.get('Blocks', [])
        
        # Look for SIGNATURE block type
        for block in blocks:
            if block.get('BlockType') == 'SIGNATURE':
                return "Yes"
                
        return "No"
        
    except Exception as e:
        print(f"Error detecting signature: {e}")
        return "Error"

def extract_name_and_date_by_pattern(raw_text):
    """Extract name and date using regex patterns specifically for the document format"""
    name = None
    date = None
    
    # Pattern for "Signed by customer: NAME"
    name_pattern = re.compile(r'Signed by customer:\s*([^\n]+)')
    name_match = name_pattern.search(raw_text)
    if name_match:
        name = name_match.group(1).strip()
        print(f"Found name by pattern: {name}")
    
    # Pattern for "Date : DATE" - more flexible to account for different spacing/formatting
    date_pattern = re.compile(r'Date\s*:\s*([0-9]{1,2}/[0-9]{1,2}/[0-9]{4}(?:\s+[0-9]{1,2}:[0-9]{2}\s*(?:AM|PM|CMT)?)?)')
    date_match = date_pattern.search(raw_text)
    if date_match:
        date = date_match.group(1).strip()
        print(f"Found date by pattern: {date}")
    
    # Additional backup pattern just looking for date format anywhere in last few lines
    if not date:
        date_backup_pattern = re.compile(r'([0-9]{1,2}/[0-9]{1,2}/[0-9]{4}(?:\s+[0-9]{1,2}:[0-9]{2}\s*(?:AM|PM|CMT)?)?)')
        # Get last 10 lines of text where date is likely to be
        last_lines = "\n".join(raw_text.split('\n')[-10:])
        date_matches = date_backup_pattern.findall(last_lines)
        if date_matches:
            date = date_matches[0].strip()
            print(f"Found date by backup pattern: {date}")
    
    return {"name": name, "date": date}

if __name__ == "__main__":
    bucket_name = "capstone-intelligent-document-processing"
    print(f"Bucket name: {bucket_name}")
    
    # Use the entity tag to get the object key
    object_key = get_s3_bucket_object_by_tag(bucket_name, entity_tag)
    print(f"Object key: {object_key}")
    
    if object_key:
        # Get Textract analysis with queries
        textract_response, raw_text = textract_analyze_with_queries(bucket_name, object_key)
        
        if textract_response and raw_text:
            # Print last 15 lines of raw text for debugging
            print("\nLast 15 lines of raw text:")
            print("\n".join(raw_text.split('\n')[-15:]))
            
            # Parse the response using trp2 library
            d = t2.TDocumentSchema().load(textract_response)
            page = d.pages[0]
            
            # Get query answers
            query_answers = d.get_query_answers(page=page)
            
            # Check for signature
            signature_present = detect_signature(textract_response)
            
            # Extract by pattern
            pattern_extraction = extract_name_and_date_by_pattern(raw_text)
            
            # Get name and date from different methods
            name = None
            date = None
            
            # First try pattern extraction (highest priority)
            if pattern_extraction["name"]:
                name = pattern_extraction["name"]
            if pattern_extraction["date"]:
                date = pattern_extraction["date"]
            
            # Then try Textract queries if patterns didn't find anything
            if not name:
                for qa in query_answers:
                    if qa[1] == "SIGNER_NAME" and qa[2]:
                        name = qa[2]
                        print(f"Found name by query: {name}")
                        break
            
            if not date:
                for qa in query_answers:
                    if qa[1] == "SIGNING_DATE" and qa[2]:
                        date = qa[2]
                        print(f"Found date by query: {date}")
                        break
            
            # Add to final results
            final_results = []
            final_results.append(["Patient Name", name if name else "Not found"])
            final_results.append(["Date", date if date else "Not found"])
            final_results.append(["Signature Present", signature_present])
            
            # Display results in a table
            print("\nExtracted Information:")
            print(tabulate(final_results, headers=["Field", "Value"], tablefmt="github"))
            
            # Format as JSON for saving
            result_dict = {
                "PatientName": name if name else "Not found",
                "Date": date if date else "Not found",
                "SignaturePresent": signature_present
            }
            
            json_output = json.dumps(result_dict, indent=4)
            
            # Save to file
            with open("extracted_info.json", "w") as json_file:
                json_file.write(json_output)
                
        else:
            print("Failed to extract data from document.")
    else:
        print("No documents found with the specified tag.")
